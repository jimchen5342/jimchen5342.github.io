<!DOCTYPE html>
<html>
<head>
	<title>繼承</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="../../jQuery/easyui/themes/default/easyui.css">
	<link rel="stylesheet" type="text/css" href="../../jQuery/easyui/themes/icon.css">
	<link rel="stylesheet" type="text/css" href="../../jQuery/easyui/themes/color.css">
	<script type="text/javascript" src="../../jQuery/jquery.min.js"></script>
	<script type="text/javascript" src="../../jQuery/easyui/jquery.easyui.min.js"></script>
	<link rel="stylesheet" href="../pattern.css">
	<script src="../../system/system.js"></script>
	<script src="../histroy.js"></script>
	<script src="../highlight.js"></script>
	<style type="text/css">
		html,
		body {
			margin: 0;
			padding: 0;
			overflow-y: auto;
			font-size: 16px;
		}

		h4 {
			display: inline-block;
		}
	</style>
</head>
<body class="easyui-tabs" style="width: 100%; height: 100%;" onresize="$('body').tabs('resize')">
	<div title="原型繼承">
		<h4>原型(prototype)</h4>
		<ol>
			<li>Javascript 是 prototype-base-oriented 的語言，而且Javascript 中的 class 並不存在
				(ES6 有提供這功能，但只是語法糖)，
				在它的世界裏只有 Object 和 Instance，當物體創建，複製或繼承通通是透過 Prototype 完成。</li>
			<li>當提到繼承時，JavaScript 只具有一個建構物：物件。<br/>
				每個物件中都會有一個 private 的屬性(prototype)連結著另外一個稱為它的原型的物件(prototype)。<br/>
				而這個原型物件也具有它自己的原型，這個鍊一直持續下去，直到有個物件的原型屬性為 null。
				在定義裡，null 沒有原型，並且為原型鍊（prototype chain）裡最後的一個連結</li>
			<li>在 JavaScript 裡，幾乎所有的物件都是 Object 的實例，這個 Object 在 prototype 鏈結的的最頂端</li>
			<li>透過修改(或者擴充)既有的 prototype 來達到類別的功能並可重複使用(等同在以類別為基礎的程式語言中的繼承)</li>
			<li>物件都有 __proto__ 屬性來標識自己所繼承的原型，只有函式才有 prototype 属性。
				當創建函數時，JS 會為這個函數自動添加 prototype 屬性，值是空對象。
				而一旦你把這個函數當作建構子(constructor)實例化(即通過new關鍵字調用)，
				那麼JS就會幫你創建該建構子的實例，實例繼承建構子 prototype 的所有屬性和方法
				(實例通過設置自己的 __proto__ 指向承建構子的 prototype 來實現這種繼承）
			</li>
		</ol>
	</div>
	<div title='物件繼承'>
		<h4>call(), apply()</h4>
		<ol>
			<li>call() 和 apply() 都是 Function 資料型別的靜態方法。</li>
			<li>call() 和 apply() 都是為了改變某個函數運行時的 context 即上下文而存在的，
				換句話說，就是為了改變函數體內部 this 的指向。</li>
			<li>call() 與 apply() 用途相同，唯一的差別在於，call() 必須一一明列出參數，而 apply() 只要傳入陣列</li>
			<li>call(obj, ...)</li>
			<li>apply(obj, [...])</li>
		</ol>
	</div>
	<div title='線上參考'>
		<a href='http://guang.logdown.com/posts/261831-javascript-oop'>Javascript 物件導向</a>
		<br/>
		<a href='https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript'>MDN - JavaScript 物件導向介紹</a>
		<br/>
		<a href='https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain'>MDN - 繼承以及原型鏈</a>
		<br/>
		<a href='https://medium.com/@peterchang_82818/javascripter-%E5%BF%85%E9%A0%88%E7%9F%A5%E9%81%93%E7%9A%84%E7%B9%BC%E6%89%BF%E5%9B%A0%E5%AD%90-prototype-prototype-proto-object-class-inheritace-nodejs-%E7%89%A9%E4%BB%B6-%E7%B9%BC%E6%89%BF-54102240a8b4'>Javascripter 必須知道的繼承 prototype</a>
	</div>


	<!--

constructor
hasOwnProperty
isPrototypeOf 
propertyIsEnumerable 
toLocaleString 
toString 
valueOf 
get 
set


<ul>
	<li>prototype</li>
	<li>call：它會以第一個引數的方法來呼叫該函數。也就是說，我們以第一個引數傳入呼叫的任何物件，將成為函數呼叫的 "this" 值。這將是呼叫基底類別建構函式的技巧</li>
	<li>apply</li>
</ul>
	constructor, instanceof
	prototype
	this: 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用
	call： Function 都會有個 call()方法，第一個參數為物件
	, apply

	Object.create(o);
	<h4></h4>
	<pre>
		<code class='javascript'>
		</code>
	</pre>

	 函式實字建立了函式實例，並指定給 toString 特性，不過每次呼叫建構式時，都會建立一次函式實例。
	 
	 使用 new 關鍵字時，JavaScript 會先建立一個空物件，
	 接著設定物件的原型為函式的 prototype 特性所參考的物件，
	 然後呼叫建構式並將所建立的空物件設為 this。 
	 JavaScript 在尋找特性名稱時，會先在實例上找尋有無特性，
	 以上例而言，p1
	上會有 name 與 age 特性，所以可以直接取得對應的值。如果物件上沒有該特性，會到物件的原型上去尋找，以上例而言，p1 上沒有 toString 特性，所以會到 p1 的原型上尋找，而 p1 的原型物件此時也就是 Person.prototype
	參考的物件，這個物件上有 toString 特性，所以可以 找到 toString 所參考的函式並執行。
-->
</body>
<script>
	$(document).ready(function(){
		$('body').tabs({
			headerWidth: 90
		});
		$('body').tabs('resize');
	});
</script>
</html>